const { exec } = require('child_process');
const { promisify } = require('util');
const axios = require('axios');
const winston = require('winston');
const moment = require('moment');
const fs = require('fs').promises;
const path = require('path');

const execAsync = promisify(exec);

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/scanner.log' })
  ]
});

class VulnerabilityScanner {
  constructor() {
    this.scanResults = new Map();
    this.activeScan = new Map();
    this.cveDatabase = new Map();
    this.loadCveDatabase();
  }

  // Load CVE database for vulnerability matching
  async loadCveDatabase() {
    try {
      // In a real implementation, this would load from a proper CVE database
      // For demo purposes, we'll use a sample dataset
      const sampleCVEs = [
        {
          id: 'CVE-2021-44228',
          description: 'Apache Log4j2 Remote Code Execution',
          severity: 'CRITICAL',
          cvssScore: 10.0,
          ports: [8080, 9200, 9300],
          services: ['tomcat', 'elasticsearch', 'solr']
        },
        {
          id: 'CVE-2021-34527',
          description: 'Windows Print Spooler Remote Code Execution',
          severity: 'HIGH',
          cvssScore: 8.8,
          ports: [445, 135],
          services: ['smb', 'rpc']
        },
        {
          id: 'CVE-2020-1472',
          description: 'Netlogon Elevation of Privilege Vulnerability',
          severity: 'CRITICAL',
          cvssScore: 10.0,
          ports: [445, 139],
          services: ['smb', 'netbios']
        },
        {
          id: 'CVE-2019-0708',
          description: 'Remote Desktop Services Remote Code Execution',
          severity: 'CRITICAL',
          cvssScore: 9.8,
          ports: [3389],
          services: ['rdp', 'ms-wbt-server']
        }
      ];

      sampleCVEs.forEach(cve => {
        this.cveDatabase.set(cve.id, cve);
      });

      logger.info(`Loaded ${sampleCVEs.length} CVE entries`);
    } catch (error) {
      logger.error('Failed to load CVE database:', error);
    }
  }

  // Perform network scan on target hosts
  async performNetworkScan(targets, options = {}) {
    const scanId = this.generateScanId();
    const startTime = moment();

    try {
      logger.info(`Starting network scan ${scanId}`, { targets, options });

      const results = {
        scanId,
        startTime: startTime.toISOString(),
        targets: Array.isArray(targets) ? targets : [targets],
        status: 'running',
        hosts: [],
        vulnerabilities: [],
        summary: {
          hostsScanned: 0,
          hostsUp: 0,
          portsFound: 0,
          vulnerabilitiesFound: 0
        }
      };

      this.scanResults.set(scanId, results);
      this.activeScan.set(scanId, true);

      // Perform the actual scanning
      for (const target of results.targets) {
        if (!this.activeScan.get(scanId)) break;

        const hostResults = await this.scanHost(target, options);
        results.hosts.push(hostResults);
        
        // Check for vulnerabilities
        const vulns = await this.checkVulnerabilities(hostResults);
        results.vulnerabilities.push(...vulns);
      }

      // Update final results
      results.status = 'completed';
      results.endTime = moment().toISOString();
      results.duration = moment().diff(startTime, 'seconds');
      results.summary = this.generateSummary(results);

      this.activeScan.delete(scanId);
      
      logger.info(`Network scan ${scanId} completed`, {
        duration: results.duration,
        hostsScanned: results.summary.hostsScanned,
        vulnerabilities: results.summary.vulnerabilitiesFound
      });

      return results;

    } catch (error) {
      logger.error(`Network scan ${scanId} failed:`, error);
      
      const results = this.scanResults.get(scanId);
      if (results) {
        results.status = 'failed';
        results.error = error.message;
        results.endTime = moment().toISOString();
      }
      
      this.activeScan.delete(scanId);
      throw error;
    }
  }

  // Scan individual host
  async scanHost(target, options = {}) {
    const hostResult = {
      target,
      status: 'unknown',
      ip: null,
      hostname: null,
      ports: [],
      services: [],
      os: null,
      lastSeen: moment().toISOString()
    };

    try {
      // Check if host is alive
      const isAlive = await this.pingHost(target);
      hostResult.status = isAlive ? 'up' : 'down';

      if (!isAlive) {
        return hostResult;
      }

      // Resolve hostname
      hostResult.hostname = await this.resolveHostname(target);
      hostResult.ip = await this.resolveIP(target);

      // Port scanning
      const ports = options.ports || this.getDefaultPorts();
      hostResult.ports = await this.scanPorts(target, ports);

      // Service detection
      hostResult.services = await this.detectServices(target, hostResult.ports);

      // OS detection
      hostResult.os = await this.detectOS(target);

      return hostResult;

    } catch (error) {
      logger.error(`Host scan failed for ${target}:`, error);
      hostResult.status = 'error';
      hostResult.error = error.message;
      return hostResult;
    }
  }

  // Check host availability with ping
  async pingHost(target) {
    try {
      const { stdout } = await execAsync(`ping -n 1 -w 1000 ${target}`);
      return stdout.includes('TTL=') || stdout.includes('time=');
    } catch (error) {
      return false;
    }
  }

  // Resolve hostname from IP or vice versa
  async resolveHostname(target) {
    try {
      const { stdout } = await execAsync(`nslookup ${target}`);
      const lines = stdout.split('\n');
      for (const line of lines) {
        if (line.includes('Name:')) {
          return line.split('Name:')[1].trim();
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }

  // Resolve IP address
  async resolveIP(target) {
    try {
      const { stdout } = await execAsync(`nslookup ${target}`);
      const ipMatch = stdout.match(/Address:\s+(\d+\.\d+\.\d+\.\d+)/);
      return ipMatch ? ipMatch[1] : target;
    } catch (error) {
      return target;
    }
  }

  // Scan ports on target host
  async scanPorts(target, ports) {
    const openPorts = [];
    const portList = Array.isArray(ports) ? ports : ports.split(',');

    try {
      // Simple TCP connect scan simulation
      for (const port of portList) {
        const isOpen = await this.checkPort(target, parseInt(port));
        if (isOpen) {
          openPorts.push({
            port: parseInt(port),
            state: 'open',
            protocol: 'tcp'
          });
        }
      }

      logger.info(`Found ${openPorts.length} open ports on ${target}`);
      return openPorts;

    } catch (error) {
      logger.error(`Port scan failed for ${target}:`, error);
      return openPorts;
    }
  }

  // Check if specific port is open
  async checkPort(host, port) {
    return new Promise((resolve) => {
      const net = require('net');
      const socket = new net.Socket();
      
      const timeout = 2000;
      socket.setTimeout(timeout);
      
      socket.on('connect', () => {
        socket.destroy();
        resolve(true);
      });
      
      socket.on('timeout', () => {
        socket.destroy();
        resolve(false);
      });
      
      socket.on('error', () => {
        resolve(false);
      });
      
      socket.connect(port, host);
    });
  }

  // Detect services running on open ports
  async detectServices(target, ports) {
    const services = [];
    
    for (const portInfo of ports) {
      const service = this.identifyService(portInfo.port);
      if (service) {
        services.push({
          port: portInfo.port,
          name: service.name,
          product: service.product,
          version: service.version,
          confidence: service.confidence
        });
      }
    }

    return services;
  }

  // Identify service by port number (simplified)
  identifyService(port) {
    const commonServices = {
      21: { name: 'ftp', product: 'FTP Server', confidence: 0.8 },
      22: { name: 'ssh', product: 'SSH Server', confidence: 0.9 },
      23: { name: 'telnet', product: 'Telnet Server', confidence: 0.9 },
      25: { name: 'smtp', product: 'SMTP Server', confidence: 0.8 },
      53: { name: 'domain', product: 'DNS Server', confidence: 0.9 },
      80: { name: 'http', product: 'HTTP Server', confidence: 0.8 },
      110: { name: 'pop3', product: 'POP3 Server', confidence: 0.8 },
      135: { name: 'msrpc', product: 'Microsoft RPC', confidence: 0.9 },
      139: { name: 'netbios-ssn', product: 'NetBIOS Session Service', confidence: 0.9 },
      143: { name: 'imap', product: 'IMAP Server', confidence: 0.8 },
      443: { name: 'https', product: 'HTTPS Server', confidence: 0.8 },
      445: { name: 'microsoft-ds', product: 'Microsoft SMB', confidence: 0.9 },
      993: { name: 'imaps', product: 'IMAP over SSL', confidence: 0.8 },
      995: { name: 'pop3s', product: 'POP3 over SSL', confidence: 0.8 },
      3306: { name: 'mysql', product: 'MySQL Database', confidence: 0.9 },
      3389: { name: 'ms-wbt-server', product: 'Microsoft RDP', confidence: 0.9 },
      5432: { name: 'postgresql', product: 'PostgreSQL Database', confidence: 0.9 }
    };

    return commonServices[port] || null;
  }

  // OS detection (simplified)
  async detectOS(target) {
    try {
      // This is a simplified OS detection
      // In a real implementation, you'd use techniques like TCP fingerprinting
      const { stdout } = await execAsync(`ping -n 1 ${target}`);
      
      if (stdout.includes('TTL=128')) {
        return { family: 'Windows', confidence: 0.7 };
      } else if (stdout.includes('TTL=64')) {
        return { family: 'Linux/Unix', confidence: 0.7 };
      }
      
      return { family: 'Unknown', confidence: 0.1 };
    } catch (error) {
      return { family: 'Unknown', confidence: 0.0 };
    }
  }

  // Check for vulnerabilities based on scan results
  async checkVulnerabilities(hostResults) {
    const vulnerabilities = [];

    try {
      for (const service of hostResults.services) {
        const cveMatches = this.matchServiceToCVE(service, hostResults.ports);
        
        for (const cve of cveMatches) {
          vulnerabilities.push({
            host: hostResults.target,
            ip: hostResults.ip,
            cveId: cve.id,
            title: cve.description,
            severity: cve.severity,
            cvssScore: cve.cvssScore,
            port: service.port,
            service: service.name,
            description: `${cve.description} detected on ${service.name} service (port ${service.port})`,
            recommendation: this.getRecommendation(cve),
            references: [`https://nvd.nist.gov/vuln/detail/${cve.id}`],
            discoveredAt: moment().toISOString()
          });
        }
      }

      // Additional vulnerability checks
      vulnerabilities.push(...this.checkCommonVulnerabilities(hostResults));

      return vulnerabilities;

    } catch (error) {
      logger.error('Vulnerability check failed:', error);
      return [];
    }
  }

  // Match services to known CVEs
  matchServiceToCVE(service, ports) {
    const matches = [];

    for (const [cveId, cveData] of this.cveDatabase) {
      // Check if service port matches CVE
      if (cveData.ports.includes(service.port)) {
        matches.push(cveData);
      }
      
      // Check if service name matches CVE
      if (cveData.services.includes(service.name)) {
        matches.push(cveData);
      }
    }

    return matches;
  }

  // Check for common vulnerabilities
  checkCommonVulnerabilities(hostResults) {
    const vulnerabilities = [];

    // Check for weak/default configurations
    if (hostResults.ports.some(p => p.port === 23)) {
      vulnerabilities.push({
        host: hostResults.target,
        ip: hostResults.ip,
        cveId: 'CONFIG-001',
        title: 'Telnet Service Enabled',
        severity: 'HIGH',
        cvssScore: 7.5,
        port: 23,
        service: 'telnet',
        description: 'Telnet service is running and transmits data in clear text',
        recommendation: 'Disable Telnet and use SSH instead',
        discoveredAt: moment().toISOString()
      });
    }

    // Check for unnecessary services
    if (hostResults.ports.some(p => p.port === 135)) {
      vulnerabilities.push({
        host: hostResults.target,
        ip: hostResults.ip,
        cveId: 'CONFIG-002',
        title: 'Microsoft RPC Service Exposed',
        severity: 'MEDIUM',
        cvssScore: 5.3,
        port: 135,
        service: 'msrpc',
        description: 'Microsoft RPC service is exposed and may be vulnerable to attacks',
        recommendation: 'Restrict RPC access or disable if not needed',
        discoveredAt: moment().toISOString()
      });
    }

    return vulnerabilities;
  }

  // Generate scan summary
  generateSummary(results) {
    return {
      hostsScanned: results.targets.length,
      hostsUp: results.hosts.filter(h => h.status === 'up').length,
      portsFound: results.hosts.reduce((sum, h) => sum + h.ports.length, 0),
      vulnerabilitiesFound: results.vulnerabilities.length,
      criticalVulns: results.vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
      highVulns: results.vulnerabilities.filter(v => v.severity === 'HIGH').length,
      mediumVulns: results.vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
      lowVulns: results.vulnerabilities.filter(v => v.severity === 'LOW').length
    };
  }

  // Get security recommendation for CVE
  getRecommendation(cve) {
    const recommendations = {
      'CVE-2021-44228': 'Update Apache Log4j to version 2.17.0 or later',
      'CVE-2021-34527': 'Install security updates and disable Print Spooler if not needed',
      'CVE-2020-1472': 'Apply security patches and enable secure channel requirements',
      'CVE-2019-0708': 'Install security updates and enable Network Level Authentication'
    };

    return recommendations[cve.id] || 'Apply security patches and follow vendor recommendations';
  }

  // Get default ports to scan
  getDefaultPorts() {
    return process.env.DEFAULT_SCAN_PORTS?.split(',') || [
      21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 3306, 3389, 5432
    ];
  }

  // Generate unique scan ID
  generateScanId() {
    return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Get scan results
  getScanResults(scanId) {
    return this.scanResults.get(scanId);
  }

  // Get all scan results
  getAllScans() {
    return Array.from(this.scanResults.values());
  }

  // Cancel active scan
  cancelScan(scanId) {
    this.activeScan.delete(scanId);
    const results = this.scanResults.get(scanId);
    if (results) {
      results.status = 'cancelled';
      results.endTime = moment().toISOString();
    }
  }

  // Clean up old scan results
  cleanupOldScans(maxAge = 7) {
    const cutoff = moment().subtract(maxAge, 'days');
    
    for (const [scanId, results] of this.scanResults) {
      if (moment(results.startTime).isBefore(cutoff)) {
        this.scanResults.delete(scanId);
      }
    }
  }
}

module.exports = VulnerabilityScanner;
